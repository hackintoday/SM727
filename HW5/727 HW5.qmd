---
title: "727 HW5"
author: "Jay Kim"
format: pdf
editor: visual
---

[Github Link](https://github.com/hackintoday/SM727/tree/main/HW5)

```{r}
#| include: false
library(tidyverse)
library(censusapi)

```

```{r}
cs_key <- read_file("API KEY.txt")

acs_il_c <- getCensus(name = "acs/acs5",
                      vintage = 2016,
                      vars = c("NAME",
                      "B01003_001E",
                      "B19013_001E",
                      "B19301_001E"),
                      region = "county:*",
                      regionin = "state:17",
                      key = cs_key) %>%
                      rename(pop = B01003_001E,
                      hh_income = B19013_001E,
                      income = B19301_001E)
head(acs_il_c)


```

```{r}
il_map <- map_data("county", region = "illinois")
head(il_map)
```

```{r}
acs_il_c <- acs_il_c %>%
  mutate(subregion = gsub(" County, Illinois", "", NAME) %>% tolower())

acs_map <- il_map %>%
  left_join(acs_il_c, by = "subregion")

head(acs_map)
```

```{r}
ggplot(acs_map) +
geom_polygon(aes(x = long,
                 y = lat,
                 group = group,
                 fill = income))
```

```{r}
# Clean the data for clustering
# Extract unique county-level data (remove duplicate rows from map data)
acs_clean <- acs_il_c %>%
  select(subregion, pop, hh_income, income) %>%
  na.omit()  # Remove any rows with missing values

# Create a matrix with county names as row names for clustering
acs_matrix <- acs_clean %>%
  select(pop, hh_income, income) %>%
  scale()  # Standardize the variables

rownames(acs_matrix) <- acs_clean$subregion

# Create the distance matrix
dist_matrix <- dist(acs_matrix, method = "euclidean")

# Perform hierarchical clustering using Ward's method
hc_ward <- hclust(dist_matrix, method = "ward.D2")

# Plot the dendrogram
plot(hc_ward, main = "Dendrogram of Illinois Counties",
     xlab = "County", ylab = "Height", cex = 0.6)

k <- 4

# Draw boxes around clusters
rect.hclust(hc_ward, k = k, border = "red")

# Cut the tree to create cluster assignments
clusters <- cutree(hc_ward, k = k)

# Create a data frame with cluster assignments
cluster_df <- data.frame(
  subregion = names(clusters),
  cluster = as.factor(clusters)
)

# Join cluster assignments with the original ACS data
acs_il_c <- acs_il_c %>%
  left_join(cluster_df, by = "subregion")

# Create new acs_map with cluster membership
acs_map <- il_map %>%
  left_join(acs_il_c, by = "subregion")

# Visualize the clusters on a map
ggplot(acs_map, aes(x = long, y = lat, group = group, fill = cluster)) +
  geom_polygon(color = "white", size = 0.2) +
  coord_fixed(1.3) +
  scale_fill_brewer(palette = "Set3", name = "Cluster") +
  theme_minimal() +
  labs(title = "Illinois County Clusters",
       subtitle = "Based on Population, Household Income, and Per Capita Income",
       x = "Longitude", y = "Latitude") +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())
```

```{r}
acs_il_t <- getCensus(name = "acs/acs5",
                      vintage = 2016,
                      vars = c("NAME",
                               "B01003_001E",
                               "B19013_001E",
                               "B19301_001E"),
                      region = "tract:*",
                      regionin = "state:17",
                      key = cs_key) %>%
  mutate(across(everything(), ~ifelse(. == -666666666, NA, .))) %>%
  rename(pop = B01003_001E, 
         hh_income = B19013_001E,
         income = B19301_001E)

head(acs_il_t)
```

```{r}
#| warning: false
# Clean the data for clustering
acs_il_t_clean <- acs_il_t %>%
  select(NAME, state, county, tract, pop, hh_income, income) %>%
  na.omit()  # Remove rows with missing values

# Create a matrix for clustering (standardized)
acs_matrix_t <- acs_il_t_clean %>%
  select(pop, hh_income, income) %>%
  scale()

# Determine optimal K using within-cluster sum of squares
# Calculate WCSS for K = 1 to 20
set.seed(123) 
wcss <- sapply(1:20, function(k) {
  kmeans(acs_matrix_t, centers = k, nstart = 25)$tot.withinss
})

# Plot the elbow curve
wcss_df <- data.frame(K = 1:20, WCSS = wcss)

ggplot(wcss_df, aes(x = K, y = WCSS)) +
  geom_line(color = "blue", size = 1) +
  geom_point(color = "red", size = 2) +
  labs(title = "Elbow Method for Optimal K",
       subtitle = "Within-Cluster Sum of Squares vs. Number of Clusters",
       x = "Number of Clusters (K)",
       y = "Within-Cluster Sum of Squares") +
  theme_minimal() +
  scale_x_continuous(breaks = 1:20)

# Run K-means with optimal K
# Adjust based on elbow plot
# 6 seems to be optimal
optimal_k <- 6
set.seed(123)
kmeans_result <- kmeans(acs_matrix_t, centers = optimal_k, nstart = 25)

# Create a temporary data frame with cluster membership for analysis
temp_clustered <- acs_il_t_clean %>%
  mutate(cluster = as.factor(kmeans_result$cluster))

# Find mean statistics and most frequent county by cluster
cluster_summary <- temp_clustered %>%
  group_by(cluster) %>%
  summarise(
    mean_pop = mean(pop, na.rm = TRUE),
    mean_hh_income = mean(hh_income, na.rm = TRUE),
    mean_income = mean(income, na.rm = TRUE),
    n_tracts = n()
  )

print("Cluster Summary Statistics:")
print(cluster_summary)

# Find most frequent county in each cluster
most_frequent_county <- temp_clustered %>%
  group_by(cluster, county) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(cluster) %>%
  slice_max(count, n = 1) %>%
  select(cluster, most_frequent_county = county, count)

print(most_frequent_county)


# Combine summaries
full_summary <- cluster_summary %>%
  left_join(most_frequent_county, by = "cluster")

print(full_summary)

# Create a function for K-means clustering
kmeans_function <- function(k, data = acs_matrix_t, seed = 123) {
  set.seed(seed)
  result <- kmeans(data, centers = k, nstart = 25)
  return(result$cluster)
}

# Iterate over multiple K values (K = 2 to 10)
k_values <- 2:10

# Apply the function for each K and create new columns
# Names is cluster_i for each iteration
for (k in k_values) {
  col_name <- paste0("cluster_", k)
  acs_il_t_clean[[col_name]] <- as.factor(kmeans_function(k))
}

# Display the first rows of the updated dataset
head(acs_il_t_clean)
```
